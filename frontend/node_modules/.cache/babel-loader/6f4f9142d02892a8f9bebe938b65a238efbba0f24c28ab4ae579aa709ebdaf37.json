{"ast":null,"code":"import { API_URL, isApiRequest } from './api';\nexport function installAuthFetchInterceptor(onExpired) {\n  if (typeof window === 'undefined') return;\n  const w = window;\n  if (w.__authFetchInstalled) return;\n  const originalFetch = window.fetch.bind(window);\n  window.fetch = async (input, init) => {\n    try {\n      const url = typeof input === 'string' ? input : input.url || String(input);\n      let targetStr = url;\n      let isApiCall = isApiRequest(url);\n      // Rewrite absolute localhost:4000 to configured API_URL (preserve path/query)\n      if (typeof url === 'string' && /^https?:\\/\\/localhost:4000\\//i.test(url)) {\n        try {\n          const u = new URL(url);\n          const base = new URL(API_URL);\n          targetStr = `${base.origin}${u.pathname}${u.search}`;\n          isApiCall = true;\n        } catch {}\n      }\n      const headers = new Headers((init === null || init === void 0 ? void 0 : init.headers) || {});\n      let attachedAuth = false;\n      if (isApiCall) {\n        const jwt = localStorage.getItem('token');\n        if (jwt && !headers.has('Authorization')) {\n          headers.set('Authorization', `Bearer ${jwt}`);\n          attachedAuth = true;\n        } else if (headers.has('Authorization')) {\n          attachedAuth = true;\n        }\n      }\n      const target = typeof input === 'string' ? targetStr : targetStr;\n      const resp = await originalFetch(target, {\n        ...init,\n        headers\n      });\n      if (isApiCall && attachedAuth && (resp.status === 401 || resp.status === 403)) {\n        try {\n          onExpired === null || onExpired === void 0 ? void 0 : onExpired();\n        } catch {}\n      }\n      return resp;\n    } catch (e) {\n      // In case of wrapping error, fallback to original fetch\n      return originalFetch(input, init);\n    }\n  };\n  w.__authFetchInstalled = true;\n}","map":{"version":3,"names":["API_URL","isApiRequest","installAuthFetchInterceptor","onExpired","window","w","__authFetchInstalled","originalFetch","fetch","bind","input","init","url","String","targetStr","isApiCall","test","u","URL","base","origin","pathname","search","headers","Headers","attachedAuth","jwt","localStorage","getItem","has","set","target","resp","status","e"],"sources":["/Users/yavuz/Desktop/portfolio/erasmus-exam-page/frontend/src/utils/installAuthFetchInterceptor.ts"],"sourcesContent":["import { API_URL, isApiRequest } from './api';\n\nexport function installAuthFetchInterceptor(onExpired: () => void) {\n  if (typeof window === 'undefined') return;\n  const w = window as any;\n  if (w.__authFetchInstalled) return;\n  const originalFetch = window.fetch.bind(window);\n  window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {\n    try {\n      const url = typeof input === 'string' ? input : (input as any).url || String(input);\n  let targetStr = url;\n  let isApiCall = isApiRequest(url);\n      // Rewrite absolute localhost:4000 to configured API_URL (preserve path/query)\n      if (typeof url === 'string' && /^https?:\\/\\/localhost:4000\\//i.test(url)) {\n        try {\n          const u = new URL(url);\n          const base = new URL(API_URL);\n          targetStr = `${base.origin}${u.pathname}${u.search}`;\n          isApiCall = true;\n        } catch {}\n      }\n      const headers = new Headers(init?.headers || {});\n      let attachedAuth = false;\n      if (isApiCall) {\n        const jwt = localStorage.getItem('token');\n        if (jwt && !headers.has('Authorization')) {\n          headers.set('Authorization', `Bearer ${jwt}`);\n          attachedAuth = true;\n        } else if (headers.has('Authorization')) {\n          attachedAuth = true;\n        }\n      }\n  const target: RequestInfo | URL = typeof input === 'string' ? targetStr : targetStr;\n      const resp = await originalFetch(target, { ...init, headers });\n      if (isApiCall && attachedAuth && (resp.status === 401 || resp.status === 403)) {\n        try { onExpired?.(); } catch {}\n      }\n      return resp;\n    } catch (e) {\n      // In case of wrapping error, fallback to original fetch\n      return originalFetch(input, init);\n    }\n  };\n  w.__authFetchInstalled = true;\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,YAAY,QAAQ,OAAO;AAE7C,OAAO,SAASC,2BAA2BA,CAACC,SAAqB,EAAE;EACjE,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;EACnC,MAAMC,CAAC,GAAGD,MAAa;EACvB,IAAIC,CAAC,CAACC,oBAAoB,EAAE;EAC5B,MAAMC,aAAa,GAAGH,MAAM,CAACI,KAAK,CAACC,IAAI,CAACL,MAAM,CAAC;EAC/CA,MAAM,CAACI,KAAK,GAAG,OAAOE,KAAwB,EAAEC,IAAkB,KAAK;IACrE,IAAI;MACF,MAAMC,GAAG,GAAG,OAAOF,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAIA,KAAK,CAASE,GAAG,IAAIC,MAAM,CAACH,KAAK,CAAC;MACvF,IAAII,SAAS,GAAGF,GAAG;MACnB,IAAIG,SAAS,GAAGd,YAAY,CAACW,GAAG,CAAC;MAC7B;MACA,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,+BAA+B,CAACI,IAAI,CAACJ,GAAG,CAAC,EAAE;QACxE,IAAI;UACF,MAAMK,CAAC,GAAG,IAAIC,GAAG,CAACN,GAAG,CAAC;UACtB,MAAMO,IAAI,GAAG,IAAID,GAAG,CAAClB,OAAO,CAAC;UAC7Bc,SAAS,GAAG,GAAGK,IAAI,CAACC,MAAM,GAAGH,CAAC,CAACI,QAAQ,GAAGJ,CAAC,CAACK,MAAM,EAAE;UACpDP,SAAS,GAAG,IAAI;QAClB,CAAC,CAAC,MAAM,CAAC;MACX;MACA,MAAMQ,OAAO,GAAG,IAAIC,OAAO,CAAC,CAAAb,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEY,OAAO,KAAI,CAAC,CAAC,CAAC;MAChD,IAAIE,YAAY,GAAG,KAAK;MACxB,IAAIV,SAAS,EAAE;QACb,MAAMW,GAAG,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;QACzC,IAAIF,GAAG,IAAI,CAACH,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC,EAAE;UACxCN,OAAO,CAACO,GAAG,CAAC,eAAe,EAAE,UAAUJ,GAAG,EAAE,CAAC;UAC7CD,YAAY,GAAG,IAAI;QACrB,CAAC,MAAM,IAAIF,OAAO,CAACM,GAAG,CAAC,eAAe,CAAC,EAAE;UACvCJ,YAAY,GAAG,IAAI;QACrB;MACF;MACJ,MAAMM,MAAyB,GAAG,OAAOrB,KAAK,KAAK,QAAQ,GAAGI,SAAS,GAAGA,SAAS;MAC/E,MAAMkB,IAAI,GAAG,MAAMzB,aAAa,CAACwB,MAAM,EAAE;QAAE,GAAGpB,IAAI;QAAEY;MAAQ,CAAC,CAAC;MAC9D,IAAIR,SAAS,IAAIU,YAAY,KAAKO,IAAI,CAACC,MAAM,KAAK,GAAG,IAAID,IAAI,CAACC,MAAM,KAAK,GAAG,CAAC,EAAE;QAC7E,IAAI;UAAE9B,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAG,CAAC;QAAE,CAAC,CAAC,MAAM,CAAC;MAChC;MACA,OAAO6B,IAAI;IACb,CAAC,CAAC,OAAOE,CAAC,EAAE;MACV;MACA,OAAO3B,aAAa,CAACG,KAAK,EAAEC,IAAI,CAAC;IACnC;EACF,CAAC;EACDN,CAAC,CAACC,oBAAoB,GAAG,IAAI;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}